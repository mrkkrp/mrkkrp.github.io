<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <meta name="author" content="Mark Karpov" />
    
    
    <title>
      Latest additions to Megaparsec
      
      by Mark Karpov
      
    </title>
    
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>

  <body>
    <a name="top"></a>
    <nav>
      <a href="../index.html">
        index
      </a>
      &middot;
      <a href="https://github.com/mrkkrp/mrkkrp.github.io/tree/src">
        src
      </a>
      &middot;
      <a href="../feed.atom">
        feed
      </a>
      &middot;
      <a href="https://creativecommons.org/licenses/by/4.0/">
        license
      </a>
      &middot;
      <a href="../contact.html">
        etc
      </a>
    </nav>

    <div class="content">
      
      <h1>
        Latest additions to Megaparsec
        
      </h1>
      
      
<p class="credit">
  by Mark Karpov
</p>



<em>
  Published on November 24, 2016
</em>


<p>I think it’s time for a little blog post summarizing progress of the Megaparsec project in the second half of 2016. There are quite a few new things I have never announced and I fear that from the changelog alone it isn’t obvious how useful they are.</p>
<h2 id="the-observing-primitive">The <code>observing</code> primitive</h2>
<p>This is a new method in the <code>MonadPasec</code> type class (added in 5.1.0), which looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">observing ::</span> <span class="dt">MonadPasrec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</code></pre></div>
<p>As you may have guessed from the signature alone, it allows to “observe” parser failure without actually ending the parsing. It does not backtrack or change behavior of <code>m a</code> parser in any way, but allows you to do something after failure.</p>
<p><a href="https://github.com/mrkkrp/megaparsec/issues/111">This issue</a> shows why we decided to add this. Thanks to <a href="https://github.com/mikeplus64">Mike Ledger</a> for opening it, as I myself didn’t think about such use case. In short, Mike wanted to annotate <code>ParseError</code>s and “label expected items by the parser that they came from”. After some discussion we came to this new primitive that is a bit more general than a labelling helper. The following program demonstrates its main use case:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span> (intercalate)
<span class="kw">import </span><span class="dt">Text.Megaparsec</span>
<span class="kw">import qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="kw">data</span> <span class="dt">Pec</span> <span class="fu">=</span> <span class="dt">Pec</span> [<span class="dt">String</span>] (<span class="dt">Maybe</span> <span class="dt">Dec</span>) <span class="co">-- (1)</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)

<span class="kw">instance</span> <span class="dt">ErrorComponent</span> <span class="dt">Pec</span> <span class="kw">where</span> <span class="co">-- (2)</span>
  representFail <span class="fu">=</span>
    <span class="dt">Pec</span> [] <span class="fu">.</span> <span class="dt">Just</span> <span class="fu">.</span> representFail
  representIndentation ord p0 p1 <span class="fu">=</span>
    (<span class="dt">Pec</span> [] <span class="fu">.</span> <span class="dt">Just</span>) (representIndentation ord p0 p1)

<span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Pec</span> <span class="kw">where</span> <span class="co">-- (3)</span>
  showErrorComponent (<span class="dt">Pec</span> ls dec) <span class="fu">=</span>
    <span class="kw">let</span> formatLabels <span class="fu">=</span> intercalate <span class="st">&quot;, &quot;</span> <span class="fu">.</span> fmap (<span class="st">&quot;in &quot;</span> <span class="fu">++</span>)
    <span class="kw">in</span> maybe <span class="st">&quot;&quot;</span> ((<span class="fu">++</span> <span class="st">&quot;\n&quot;</span>) <span class="fu">.</span> showErrorComponent) dec <span class="fu">++</span> formatLabels ls

<span class="kw">type</span> <span class="dt">Parser</span> <span class="fu">=</span> <span class="dt">Parsec</span> <span class="dt">Pec</span> <span class="dt">String</span> <span class="co">-- (4)</span>

<span class="ot">attachLabel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
attachLabel l m <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> observing m <span class="co">-- (5)</span>
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">Left</span> <span class="dt">ParseError</span> {<span class="fu">..</span>} <span class="ot">-&gt;</span>
      failure errorUnexpected errorExpected <span class="fu">$</span> <span class="co">-- (6)</span>
        <span class="kw">if</span> S.null errorCustom
          <span class="kw">then</span> S.singleton (<span class="dt">Pec</span> [l] <span class="dt">Nothing</span>)
          <span class="kw">else</span> S.map f errorCustom
      <span class="kw">where</span>
        f (<span class="dt">Pec</span> ls x) <span class="fu">=</span> <span class="dt">Pec</span> (l<span class="fu">:</span>ls) x
    <span class="dt">Right</span> x <span class="ot">-&gt;</span> return x

<span class="ot">foo ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
foo <span class="fu">=</span> attachLabel <span class="st">&quot;foo&quot;</span> bar

<span class="ot">bar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
bar <span class="fu">=</span> attachLabel <span class="st">&quot;bar&quot;</span> (char <span class="ch">'a'</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> parseTest foo <span class="st">&quot;b&quot;</span></code></pre></div>
<p>If the code is puzzling to you, start with <a href="https://mrkkrp.github.io/megaparsec/tutorials/custom-error-messages.html">this tutorial</a> I have written by popular request to explain how to do custom error messages with Megaparsec 5. Here I’ll just explain how the labelling feature works.</p>
<ol style="list-style-type: decimal">
<li><p>The <code>Pec</code> data type represents custom part of parse errors. By design it must be able to represent two things: message that was given to <code>fail</code> and typed data about indentation error. In each case we want to support a stack of labels, so we start with <code>[String]</code> and add <code>Dec</code> — default error component that comes with Megaparsec out-of-box. Finally, even if we don’t have anything custom (that <code>Dec</code> represents), we want a place where to keep the stack anyway, so we need to allow <code>Dec</code> to be missing, hence the <code>Maybe</code> wrapper.</p></li>
<li><p><code>representFail</code> and <code>representIndentation</code> are used by the library to encode information when <code>fail</code> is used or indentation error occures. We just reuse the <code>Dec</code> instance and wrap it with empty label stack.</p></li>
<li><p>Here we have a chance to decide how to display the error component. We just display <code>Dec</code> if it’s there, but in any case we want to append the label stack.</p></li>
<li><p>This is the type of parser we will be using.</p></li>
<li><p>We use <code>observing</code> because in case of failure we don’t want to end parsing immediately as we would have no chance to attach anything or otherwise influence the generated <code>ParseError</code>.</p></li>
<li><p>In case of failure we either create a new error component if the set is empty, or grow every element of the set consing a label to it. (Remember, this is a <code>Set</code> because there may be several branches of parsing, each failing at the same source position, so every component must be mergeable. Most of the time the <code>Set</code> will contain only one element though.)</p></li>
</ol>
<p>This program prints:</p>
<pre><code>1:1:
unexpected 'b'
expecting 'a'
in foo, in bar</code></pre>
<p>This new sort of label (not to be confused with <code>label</code> and <code>(&lt;?&gt;)</code>) may be constructed dynamically, allowing tracking where exactly parse error happened.</p>
<p>Now we are fully equipped to write a Megaparsec JSON parser with nice error messages :-D I believe it could report very precisely where a parse error occurred. Unfortunately I myself don’t have the time and much need for it, but maybe someone reading this post could write such a parser? It would a nice library to have.</p>
<h2 id="improved-support-for-testing">Improved support for testing</h2>
<p>For quite some time there has been a library called <a href="https://hackage.haskell.org/package/hspec-megaparsec"><code>hspec-megaparsec</code></a>, which provides helpers for testing Megaparsec parsers with Hspec. I never announced it and I’m not sure how many Megaparsec users know about it, but this is now the recommended way to test Megaparsec parsers.</p>
<p>Just to get a taste of the library, testing looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">describe <span class="st">&quot;eol&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
  context <span class="st">&quot;when stream begins with a newline&quot;</span> <span class="fu">$</span>
    it <span class="st">&quot;succeeds returning the newline&quot;</span> <span class="fu">$</span>
      property <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="kw">let</span> s' <span class="fu">=</span> <span class="ch">'\n'</span> <span class="fu">:</span> s
        prs  eol s' <span class="ot">`shouldParse`</span>     <span class="st">&quot;\n&quot;</span>
        prs' eol s' <span class="ot">`succeedsLeaving`</span> s
  context <span class="st">&quot;when stream begins with CRLF sequence&quot;</span> <span class="fu">$</span>
    it <span class="st">&quot;parses the CSRF sequence&quot;</span> <span class="fu">$</span>
      property <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="kw">let</span> s' <span class="fu">=</span> <span class="ch">'\r'</span> <span class="fu">:</span> <span class="ch">'\n'</span> <span class="fu">:</span> s
        prs  eol s' <span class="ot">`shouldParse`</span>     <span class="st">&quot;\r\n&quot;</span>
        prs' eol s' <span class="ot">`succeedsLeaving`</span> s

<span class="co">-- Helpers:</span>
<span class="co">-- prs p = parse p &quot;&quot;</span>
<span class="co">-- prs' p s = runParser' p (initialState s)</span></code></pre></div>
<p>I think this is very nice. In version 5.1, I have rewritten the entire Megaparsec’s test suite using Hspec and <code>hspec-megaparsec</code> (previously it was a combination of <code>HUnit</code>, <code>QuickCheck</code>, and <code>test-framework</code> as a glue). This forced one addition to <code>hspec-megaparsec</code> without which it could not be used in Megaparsec’s test suite: combinators for parse error construction.</p>
<p>One advantage of Megaparsec over Parsec is its clear, typed, extensible, and comparable for equality parse errors. In Megaparsec test suite there are literally hundreds of tests that check exactly which parse errors we get in every case. On one hand <code>ParseError</code> record is really great as every possible existing value of type <code>ParseError</code> is a valid parse error that doesn’t need any normalization. On the other hand, using <code>Set</code>s and <code>NonEmpty</code> lists in <code>ParseError</code> makes it a bit verbose to work with.</p>
<p>The solution is now included in <code>hspec-megaparsec</code> in the form of a simple set of monoidal values to build reference <code>ParseError</code>s from, take a look:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">context <span class="st">&quot;when stream begins with '\\r', but it's not followed by '\\n'&quot;</span> <span class="fu">$</span>
  it <span class="st">&quot;signals correct parse error&quot;</span> <span class="fu">$</span>
    property <span class="fu">$</span> \ch <span class="ot">-&gt;</span> ch <span class="fu">/=</span> <span class="ch">'\n'</span> <span class="fu">==&gt;</span> <span class="kw">do</span>
      <span class="kw">let</span> s <span class="fu">=</span> [<span class="ch">'\r'</span>,ch]
      prs eol s <span class="ot">`shouldFailWith`</span> err posI
        (utoks s <span class="fu">&lt;&gt;</span> utok <span class="ch">'\r'</span> <span class="fu">&lt;&gt;</span> elabel <span class="st">&quot;end of line&quot;</span>)
context <span class="st">&quot;when input stream is '\\r'&quot;</span> <span class="fu">$</span>
  it <span class="st">&quot;signals correct parse error&quot;</span> <span class="fu">$</span>
    prs eol <span class="st">&quot;\r&quot;</span> <span class="ot">`shouldFailWith`</span> err posI
      (utok <span class="ch">'\r'</span> <span class="fu">&lt;&gt;</span> elabel <span class="st">&quot;end of line&quot;</span>)
context <span class="st">&quot;when stream does not begin with newline or CSRF sequence&quot;</span> <span class="fu">$</span>
  it <span class="st">&quot;signals correct parse error&quot;</span> <span class="fu">$</span>
    property <span class="fu">$</span> \ch s <span class="ot">-&gt;</span> (ch <span class="ot">`notElem`</span> <span class="st">&quot;\r\n&quot;</span>) <span class="fu">==&gt;</span> <span class="kw">do</span>
      <span class="kw">let</span> s' <span class="fu">=</span> ch <span class="fu">:</span> s
      prs eol s' <span class="ot">`shouldFailWith`</span> err posI
        (utok ch <span class="fu">&lt;&gt;</span> elabel <span class="st">&quot;end of line&quot;</span>)
context <span class="st">&quot;when stream is empty&quot;</span> <span class="fu">$</span>
  it <span class="st">&quot;signals correct parse error&quot;</span> <span class="fu">$</span>
    prs eol <span class="st">&quot;&quot;</span> <span class="ot">`shouldFailWith`</span> err posI
      (ueof <span class="fu">&lt;&gt;</span> elabel <span class="st">&quot;end of line&quot;</span>)</code></pre></div>
<p><code>err</code> takes position (<code>posI</code> means initial position) and a value that describes components of a parse error. <code>utoks</code> stands for “unexpected tokens”, <code>elabel</code> means “expecting thing with this label”, etc. See <a href="https://hackage.haskell.org/package/hspec-megaparsec-0.3.0/docs/Test-Hspec-Megaparsec.html#g:3">the documentation</a> for full list of helpers.</p>
<p>Another testing-related addition in version 5.1 is that most types in Megaparsec now have <code>Arbitrary</code> instances, so you don’t need to define orphan instances again and again in your test suites.</p>
<h2 id="improved-support-for-debugging">Improved support for debugging</h2>
<p>Debugging a Megaparsec parser can be frustrating. Even if you understand exactly how evaluation proceeds, mentally going through the parser is a lot of work. Megaparsec 5.1 adds <code>dbg</code> — a debugging helper. It’s very useful!</p>
<p>Suppose you have a parser that behaves strangely:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringLiteral ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
stringLiteral <span class="fu">=</span> catMaybes <span class="fu">&lt;$&gt;</span> (char <span class="ch">'&quot;'</span> <span class="fu">&gt;&gt;</span> manyTill ch (char <span class="ch">'&quot;'</span>))
  <span class="kw">where</span> ch <span class="fu">=</span> (<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span> L.charLiteral) <span class="fu">&lt;|&gt;</span> (<span class="dt">Nothing</span> <span class="fu">&lt;$</span> string <span class="st">&quot;\\&amp;&quot;</span>)</code></pre></div>
<p>The parser <code>stringLiteral</code> should parse string literals respecting the <code>\&amp;</code> combination that can delimit characters as in <code>\x123\&amp;4</code> (which is two characters long, without <code>\&amp;</code>, <code>4</code> would merge with the previous character <code>\x123</code>). Let’s run it:</p>
<pre><code>λ&gt; parseTest stringLiteral &quot;\&quot;\\x123\\&amp;4\&quot;&quot;
&quot;\291\&amp;4&quot;</code></pre>
<p>When I first got this result it wasn’t obvious to me that <code>\&amp;</code> is not there, it’s just how pretty-printer prints the string, it inserts <code>\&amp;</code> to delimit the characters. So I wondered for a moment where did <code>\&amp;</code> come from (how silly of me!). With <code>dbg</code> it’s easy to understand what’s going on:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringLiteral ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
stringLiteral <span class="fu">=</span> catMaybes <span class="fu">&lt;$&gt;</span>
  (dbg <span class="st">&quot;open&quot;</span> (char <span class="ch">'&quot;'</span>) <span class="fu">&gt;&gt;</span> manyTill ch (dbg <span class="st">&quot;close&quot;</span> <span class="fu">$</span> char <span class="ch">'&quot;'</span>))
  <span class="kw">where</span> ch <span class="fu">=</span> (<span class="dt">Just</span>    <span class="fu">&lt;$&gt;</span> dbg <span class="st">&quot;lit&quot;</span> L.charLiteral)
         <span class="fu">&lt;|&gt;</span> (<span class="dt">Nothing</span> <span class="fu">&lt;$</span>  dbg <span class="st">&quot;del&quot;</span> (string <span class="st">&quot;\\&amp;&quot;</span>))</code></pre></div>
<p><code>dbg label p</code> takes a label <code>label</code> and a parser <code>p</code> and works just like <code>p</code>, except it lets you know what is going on in Megaparsec’s internals:</p>
<pre><code>λ&gt; parseTest stringLiteral &quot;\&quot;\\x123\\&amp;4\&quot;&quot;
open&gt; IN: &quot;&quot;\x123\&amp;4&quot;&quot;
open&gt; MATCH (COK): '&quot;'
open&gt; VALUE: '&quot;'

close&gt; IN: &quot;\x123\&amp;4&quot;&quot;
close&gt; MATCH (EERR): &lt;EMPTY&gt;
close&gt; ERROR:
close&gt; 1:2:
close&gt; unexpected '\'
close&gt; expecting '&quot;'

lit&gt; IN: &quot;\x123\&amp;4&quot;&quot;
lit&gt; MATCH (COK): &quot;\x123&quot;
lit&gt; VALUE: '\291'

close&gt; IN: &quot;\&amp;4&quot;&quot;
close&gt; MATCH (EERR): &lt;EMPTY&gt;
close&gt; ERROR:
close&gt; 1:7:
close&gt; unexpected '\'
close&gt; expecting '&quot;'

lit&gt; IN: &quot;\&amp;4&quot;&quot;
lit&gt; MATCH (EERR): &lt;EMPTY&gt;
lit&gt; ERROR:
lit&gt; 1:7:
lit&gt; unexpected '\'
lit&gt; expecting literal character

del&gt; IN: &quot;\&amp;4&quot;&quot;
del&gt; MATCH (COK): &quot;\&amp;&quot;
del&gt; VALUE: &quot;\\&amp;&quot;

close&gt; IN: &quot;4&quot;&quot;
close&gt; MATCH (EERR): &lt;EMPTY&gt;
close&gt; ERROR:
close&gt; 1:9:
close&gt; unexpected '4'
close&gt; expecting '&quot;'

lit&gt; IN: &quot;4&quot;&quot;
lit&gt; MATCH (COK): '4'
lit&gt; VALUE: '4'

close&gt; IN: '&quot;'
close&gt; MATCH (COK): '&quot;'
close&gt; VALUE: '&quot;'

&quot;\291\&amp;4&quot;</code></pre>
<p>Step by step, all the parsers we wrapped with <code>dbg</code> tell us what happens to them. It even tells you which continuation the parser follows after every step. Consult <a href="https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec.html#v:dbg">the docs</a> to learn what <code>COK</code> and <code>EERR</code> friends mean.</p>
<p>The addition of <code>dbg</code> was inspired by <a href="https://github.com/mrkkrp/megaparsec/issues/115">this issue</a>, thanks to <a href="https://github.com/flip111">flip111</a>. (Parsec users <a href="https://github.com/aslatter/parsec/issues/63">also want this</a>. Maybe it’s worth sending a PR?)</p>
<h2 id="conclusion">Conclusion</h2>
<p>There are more improvements, but these are the most important ones so far. See <a href="https://github.com/mrkkrp/megaparsec/blob/master/CHANGELOG.md">the changelog</a> for full list of changes.</p>
<p>Just in case you’ve never heard of this Megaparsec library before, here are the links:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/megaparsec">Megaparsec on Hackage</a></li>
<li><a href="https://github.com/mrkkrp/megaparsec">GitHub repo</a></li>
<li><a href="https://mrkkrp.github.io/megaparsec/">Site</a></li>
<li><a href="https://mrkkrp.github.io/megaparsec/tutorials">Tutorials</a></li>
</ul>

    </div>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="../js/put-anchors.js"></script>
    <footer>
      <a href="#top">top</a>
    </footer>

  </body>
</html>
