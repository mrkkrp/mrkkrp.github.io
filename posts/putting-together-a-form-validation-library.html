<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <meta name="author" content="Mark Karpov" />
    
    
    <title>
      Putting together a form validation library
      
      by Mark Karpov
      
    </title>
    
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
  </head>

  <body>
    <a name="top"></a>
    <nav>
      <a href="../index.html">
        index
      </a>
      &middot;
      <a href="https://github.com/mrkkrp/mrkkrp.github.io/tree/src">
        src
      </a>
      &middot;
      <a href="../feed.atom">
        feed
      </a>
      &middot;
      <a href="https://creativecommons.org/licenses/by/4.0/">
        license
      </a>
      &middot;
      <a href="../contact.html">
        etc
      </a>
    </nav>

    <div class="content">
      
      <h1>
        Putting together a form validation library
        
      </h1>
      
      
<p class="credit">
  by Mark Karpov
</p>



<em>
  Published on May  2, 2017
</em>


<p>This time I want to talk about something as boring as parsing and validating of a form on a web site. That’s a pretty common thing in web development, yet for a long time I was not satisfied with Haskell solutions we have so far. So recently a I’ve published the <a href="https://github.com/mrkkrp/forma"><code>forma</code></a> package that solves server-side part of the task.</p>
<h2 id="vanilla-forms-vs-sending-json">Vanilla forms vs sending JSON</h2>
<p>I think that serializing a form in JSON format and sending that via an AJAX request is a better strategy than traditional form submission, for several reasons:</p>
<ul>
<li><p>Smoother user experience: no need to reload the whole page.</p></li>
<li><p>Form rendering is separated and lives only in GET handler, POST (or whatever method you deem appropriate for your use case) handler only handles validation and actual effects that form submission should initiate.</p></li>
<li><p>You get a chance to organize form input just like you want.</p></li>
</ul>
<h2 id="templates-frontend-defining-scope">Templates, frontend… defining scope</h2>
<p>Of course this approach requires a bit of front-end coding. There are many alternatives:</p>
<ul>
<li><p>Vanilla JavaScript and jQuery—still an option if you need just some lightweight helpers.</p></li>
<li><p>For typed-fronted: GHCJS, PureScript, Elm, etc.</p></li>
<li><p>Who knows what else is happening is JavaScript world right now.</p></li>
</ul>
<p>So I decided that I’ll leave writing that tiny bit of front end code to the users of <code>forma</code>, so they could use whatever they prefer, and will concentrate on parsing and validation of JSON data itself.</p>
<p>I also do not want to generate the forms themselves as it tends to be not flexible enough. With <code>yesod-form</code>, I <a href="https://github.com/yesodweb/yesod/issues/1197">could not even render a checkbox properly with Bootstrap 3</a>, not to mention more custom stuff. If I remember correctly Yesod’s form system separates what you can tweak in a field and what can be tweaked in a function like <code>renderBootstrap3</code>, and it does get in your way, as this simple checkbox example shows, the types do not allow you pass a hint of what type of field you have so <code>renderBootstrap3</code> could wrap different fields differently (you could still hack, but it’s not worth it). So I decided I’ll write the markup myself, or at least define widgets per field type (parametrized in a nice typed way) and construct forms from that (but it’s a topic for a different blog post).</p>
<p>If you have used <a href="https://hackage.haskell.org/package/digestive-functors-heist"><code>digestive-functors-heist</code></a>, it’s pretty close to constructing forms from per-field widgets in Yesod, but be careful not to make a typo or use a wrong type of input, just like most part of Snap ecosystem, it’s all too dynamic and error-prone (not a fun of Snap!).</p>
<p>So I think it’s best not to constrain end user and let him/her choose how to render forms and what front-end solution to use. With scope of <code>forma</code> defined, we can start.</p>
<h2 id="the-aim">The aim</h2>
<p>I’d like to grab a <code>Value</code> and parse it, validate the parsed values in parallel, then I want to return another <code>Value</code> to send as response body back. It’s easy to get it wrong though.</p>
<h2 id="parsing-and-validation">Parsing and validation</h2>
<p>Immediately, there seem to be two types of errors that should be treated differently:</p>
<ol style="list-style-type: decimal">
<li><p>Parse errors (when we fail to deconstruct given <code>Value</code>)—these are fatal, and should cause short-circuiting behavior.</p></li>
<li><p>Validation errors—these should be collected “in parallel” from all fields, because we want to return all errors at once.</p></li>
</ol>
<p>The point 2 immediately limits us to <code>Applicative</code>, because we want to continue after a failure. It’s easy to understand this because to define <code>Monad</code> you need to define <code>(&gt;&gt;=)</code>, which is the essence of a computation with context that depends on previous value. With 2 in mind, if validation fails, we would have nothing to give to <code>f</code> in <code>m &gt;&gt;= f</code>.</p>
<p>So the first thing to define is the state of a branch of parsing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | State of a parsing branch.</span>

<span class="kw">data</span> <span class="dt">BranchState</span> a
  <span class="fu">=</span> <span class="dt">ParsingFailed</span> <span class="dt">String</span>
    <span class="co">-- ^ Parsing of JSON failed, this is fatal, we shut down and report the</span>
    <span class="co">-- parsing error.</span>
  <span class="fu">|</span> <span class="dt">ValidationFailed</span> <span class="dt">FieldError</span>
    <span class="co">-- ^ Validation of a field failed. This is also fatal but we still try</span>
    <span class="co">-- to validate other branches (fields) to collect as many validation</span>
    <span class="co">-- errors as possible.</span>
  <span class="fu">|</span> <span class="dt">Succeeded</span> a
    <span class="co">-- ^ Success, we've got a result to return.</span>
  <span class="kw">deriving</span> <span class="dt">Functor</span></code></pre></div>
<p>GHC can define <code>Functor</code> instance for us since it’s trivial. <code>Applicative</code> looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">BranchState</span> <span class="kw">where</span>
  pure                                            <span class="fu">=</span> <span class="dt">Succeeded</span>
  (<span class="dt">ParsingFailed</span> msg)   <span class="fu">&lt;*&gt;</span> _                     <span class="fu">=</span> <span class="dt">ParsingFailed</span> msg
  (<span class="dt">ValidationFailed</span> _)  <span class="fu">&lt;*&gt;</span> (<span class="dt">ParsingFailed</span> msg)   <span class="fu">=</span> <span class="dt">ParsingFailed</span> msg
  (<span class="dt">ValidationFailed</span> e0) <span class="fu">&lt;*&gt;</span> (<span class="dt">ValidationFailed</span> e1) <span class="fu">=</span> <span class="dt">ValidationFailed</span> (e0 <span class="fu">&lt;&gt;</span> e1)
  (<span class="dt">ValidationFailed</span> e)  <span class="fu">&lt;*&gt;</span> <span class="dt">Succeeded</span> _           <span class="fu">=</span> <span class="dt">ValidationFailed</span> e
  <span class="dt">Succeeded</span> _           <span class="fu">&lt;*&gt;</span> (<span class="dt">ParsingFailed</span> msg)   <span class="fu">=</span> <span class="dt">ParsingFailed</span> msg
  <span class="dt">Succeeded</span> _           <span class="fu">&lt;*&gt;</span> (<span class="dt">ValidationFailed</span> e)  <span class="fu">=</span> <span class="dt">ValidationFailed</span> e
  <span class="dt">Succeeded</span> f           <span class="fu">&lt;*&gt;</span> <span class="dt">Succeeded</span> x           <span class="fu">=</span> <span class="dt">Succeeded</span> (f x)</code></pre></div>
<p>The reader may notice similarities with <a href="https://hackage.haskell.org/package/Validation"><code>Validation</code></a>, but I also needed <code>ParsingFailed</code> to terminate the whole thing, so this is a sort of hybride between <code>Validation</code> and <code>Either</code>.</p>
<p>Next thing would be to define the applicative parser itself, easily done:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FormParser</span> m a
  <span class="fu">=</span> <span class="dt">FormParser</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> m (<span class="dt">BranchState</span> a))

<span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">FormParser</span> m) <span class="kw">where</span>
  fmap f (<span class="dt">FormParser</span> x) <span class="fu">=</span> <span class="dt">FormParser</span> (fmap (fmap f) <span class="fu">.</span> x)

<span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">FormParser</span> m) <span class="kw">where</span>
  pure x <span class="fu">=</span> (<span class="dt">FormParser</span> <span class="fu">.</span> const <span class="fu">.</span> pure) (<span class="dt">Succeeded</span> x)
  (<span class="dt">FormParser</span> f) <span class="fu">&lt;*&gt;</span> (<span class="dt">FormParser</span> x) <span class="fu">=</span> <span class="dt">FormParser</span> <span class="fu">$</span> \v <span class="ot">-&gt;</span>
    pure (<span class="fu">&lt;*&gt;</span>) <span class="fu">&lt;*&gt;</span> f v <span class="fu">&lt;*&gt;</span> x v

<span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">FormParser</span> m) <span class="kw">where</span>
  empty <span class="fu">=</span> (<span class="dt">FormParser</span> <span class="fu">.</span> const <span class="fu">.</span> pure) (<span class="dt">ParsingFailed</span> <span class="st">&quot;empty&quot;</span>)
  (<span class="dt">FormParser</span> x) <span class="fu">&lt;|&gt;</span> (<span class="dt">FormParser</span> y) <span class="fu">=</span> <span class="dt">FormParser</span> <span class="fu">$</span> \v <span class="ot">-&gt;</span>
    <span class="kw">let</span> g x' y' <span class="fu">=</span>
          <span class="kw">case</span> x' <span class="kw">of</span>
            <span class="dt">ParsingFailed</span>    _ <span class="ot">-&gt;</span> y'
            <span class="dt">ValidationFailed</span> _ <span class="ot">-&gt;</span> x'
            <span class="dt">Succeeded</span>        _ <span class="ot">-&gt;</span> x'
    <span class="kw">in</span> pure g <span class="fu">&lt;*&gt;</span> x v <span class="fu">&lt;*&gt;</span> y v</code></pre></div>
<p>Just think what such a parser should be? It should take a <code>Value</code> and return result, which is already modelled by <code>BranchState</code>, so we just wrap that function, call it <code>FormParser</code> and let the types guide us.</p>
<p>An important thing to note that with the short-circuiting behavior of <code>ParsingFailed</code>, we can define a meaningful <code>Alternative</code>, which means we will be able to use <code>optional</code> and <code>(&lt;|&gt;)</code> in our parsers instead of what <code>digestive-functors</code> do (they have <code>text</code> and then <code>optionalText</code>, and so for every field type, yuck).</p>
<h2 id="field-names">Field names</h2>
<p>I hate typos, so I always thought that it would be nice if something could catch them for me. Also I want something to force me into updating field names everywhere, should I decide to rename them. Since field names for forms are usually known at compile time, I decided to keep them at the type level.</p>
<p>If we start by defining a collection of field names like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">LoginFields</span> <span class="fu">=</span> <span class="ch">'[&quot;username&quot;, &quot;password&quot;, &quot;remember_me&quot;]</span></code></pre></div>
<p>Then it’s easy to force the user to pick from those names only. This solves the typo problem, and also will force to update fields everywhere in the case of renaming. So here we go:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">SelectedName</span> (<span class="ot">names ::</span> [<span class="dt">Symbol</span>])
  <span class="fu">=</span> <span class="dt">SelectedName</span> <span class="dt">Text</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">type</span> family <span class="dt">InSet</span> (<span class="ot">n ::</span> <span class="dt">Symbol</span>) (<span class="ot">ns ::</span> [<span class="dt">Symbol</span>])<span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
  <span class="dt">InSet</span> n <span class="ch">'[]    = TypeError</span>
    (<span class="ch">'Text &quot;The name &quot; '</span><span class="fu">:&lt;&gt;:</span> <span class="ch">'ShowType n '</span><span class="fu">:&lt;&gt;:</span> <span class="ch">'Text &quot; is not in the given set.&quot;</span>
     <span class="ch">':$$:</span>
     <span class="ch">'Text &quot;Either it'</span>s a typo or you need to add it to the set first<span class="fu">.</span><span class="st">&quot;)</span>
<span class="st">  InSet n (n:ns) = ()</span>
<span class="st">  InSet n (m:ns) = InSet n ns</span>

<span class="st">-- | Pick a name from a given collection of names.</span>
<span class="st">--</span>
<span class="st">-- Typical usage:</span>
<span class="st">--</span>
<span class="st">-- &gt; type Fields = '[&quot;</span>foo<span class="st">&quot;, &quot;</span>bar<span class="st">&quot;, &quot;</span>baz<span class="st">&quot;]</span>
<span class="st">-- &gt;</span>
<span class="st">-- &gt; myName :: SelectedName Fields</span>
<span class="st">-- &gt; myName = pick @&quot;</span>foo<span class="st">&quot; @Fields</span>
<span class="st">--</span>
<span class="st">-- It's a good idea to use 'pick' to get field names not only where this</span>
<span class="st">-- approach is imposed by the library, but everywhere you need to use the</span>
<span class="st">-- field names, in your templates for example.</span>

<span class="st">pick :: forall (name :: Symbol) (names :: [Symbol]).</span>
<span class="st">  ( KnownSymbol name</span>
<span class="st">  , InSet name names )</span>
<span class="st">  =&gt; SelectedName names</span>
<span class="st">pick = (SelectedName . T.pack . symbolVal) (Proxy :: Proxy name)</span>

<span class="st">-- | Extract a 'Text' value from 'SelectedName'.</span>

<span class="st">unSelectedName :: SelectedName names -&gt; Text</span>
<span class="st">unSelectedName (SelectedName txt) = txt</span></code></pre></div>
<p>I just don’t export the <code>SelectedName</code> constructor and the only way to get a <code>SelectedName</code> is via the <code>pick</code> smart constructor which also attaches the tag in the form of a set of field names at the type level to that value. We now statically know that given <code>Text</code> value is in that set.</p>
<p>We need now to index <code>BranchState</code> and <code>FormParser</code> by that collection of names too:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BranchState</span> (<span class="ot">names ::</span> [<span class="dt">Symbol</span>]) a <span class="fu">=</span> …
<span class="kw">newtype</span> <span class="dt">FormParser</span> (<span class="ot">names ::</span> [<span class="dt">Symbol</span>]) m a <span class="fu">=</span> …</code></pre></div>
<h2 id="field-errors">Field errors</h2>
<p>We can now apply the machinery to define <code>FieldError</code> and a smart constructor for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Error info in JSON format associated with a particular form field.</span>
<span class="co">-- Parametrized by @names@, which is a collection of field names (on type</span>
<span class="co">-- level) the target field belongs to. 'FieldError' is an instance of</span>
<span class="co">-- 'Semigroup' and that's how you combine values of that type. Note that</span>
<span class="co">-- it's not a 'Monoid', because we do not want to allow empty 'FieldError's.</span>

<span class="kw">data</span> <span class="dt">FieldError</span> (<span class="ot">names ::</span> [<span class="dt">Symbol</span>])
  <span class="fu">=</span> <span class="dt">FieldError</span> (<span class="dt">Map</span> <span class="dt">Text</span> <span class="dt">Value</span>)
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">FieldError</span> names) <span class="kw">where</span>
  (<span class="dt">FieldError</span> x) <span class="fu">&lt;&gt;</span> (<span class="dt">FieldError</span> y) <span class="fu">=</span> <span class="dt">FieldError</span> (M.union x y)

<span class="co">-- | This is a smart constructor for the 'FieldError' type, and the only way</span>
<span class="co">-- to obtain values of that type.</span>
<span class="co">--</span>
<span class="co">-- Typical usage:</span>
<span class="co">--</span>
<span class="co">-- &gt; type Fields = '[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="co">-- &gt;</span>
<span class="co">-- &gt; myError :: FieldError Fields</span>
<span class="co">-- &gt; myError = mkFieldError (pick @&quot;foo&quot; @Fields) &quot;That's all wrong.&quot;</span>
<span class="co">--</span>
<span class="co">-- See also: 'pick' (to create 'SelectedName').</span>

<span class="ot">mkFieldError ::</span> <span class="dt">ToJSON</span> e
  <span class="ot">=&gt;</span> <span class="dt">SelectedName</span> names <span class="co">-- ^ The field name</span>
  <span class="ot">-&gt;</span> e                 <span class="co">-- ^ Data that represents error</span>
  <span class="ot">-&gt;</span> <span class="dt">FieldError</span> names
mkFieldError name x <span class="fu">=</span>
  <span class="dt">FieldError</span> (M.singleton (unSelectedName name) (toJSON x))</code></pre></div>
<h2 id="field-parser">Field parser</h2>
<p>Now we can define a parser for a single field:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">field ::</span> forall (<span class="ot">name ::</span> <span class="dt">Symbol</span>) (<span class="ot">names ::</span> [<span class="dt">Symbol</span>]) m e s a<span class="fu">.</span>
  ( <span class="dt">KnownSymbol</span> name
  , <span class="dt">InSet</span> name names
  , <span class="dt">Monad</span> m
  , <span class="dt">ToJSON</span> e
  , <span class="dt">FromJSON</span> s )
  <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e m a)
     <span class="co">-- ^ Checker that performs validation and possibly transformation of</span>
     <span class="co">-- the field value</span>
  <span class="ot">-&gt;</span> <span class="dt">FormParser</span> names m a
field check <span class="fu">=</span> <span class="dt">FormParser</span> <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span>
  <span class="kw">let</span> name <span class="fu">=</span> pick <span class="fu">@</span>name <span class="fu">@</span>names
<span class="ot">      f ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">A.Parser</span> s
      f <span class="fu">=</span> withObject <span class="st">&quot;form field&quot;</span> (<span class="fu">.:</span> unSelectedName name)
      r <span class="fu">=</span> A.parseEither f v
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">Left</span> parseError <span class="ot">-&gt;</span> pure (<span class="dt">ParsingFailed</span> parseError)
    <span class="dt">Right</span> r' <span class="ot">-&gt;</span> <span class="kw">do</span>
      e <span class="ot">&lt;-</span> runExceptT (check r')
      return <span class="fu">$</span> <span class="kw">case</span> e <span class="kw">of</span>
        <span class="dt">Left</span> verr <span class="ot">-&gt;</span>
          (<span class="dt">ValidationFailed</span> (mkFieldError name verr))
        <span class="dt">Right</span> x <span class="ot">-&gt;</span>
          (<span class="dt">Succeeded</span> x)</code></pre></div>
<p>So this assumes that the top level <code>Value</code> is a dictionary and every its properly or key-vaule pair is a field. That’s the format of input we want to parse.</p>
<p>Typical usage makes a good use of a newer GHC feature called <code>TypeApplications</code>, it looks like this:</p>
<pre><code>myFieldParser = field @&quot;username&quot; myChecker</code></pre>
<p>This lightweight <code>@&quot;username&quot;</code> syntax unifies the type variable <code>name</code> (of the kind <code>Symbol</code>) with <code>&quot;username&quot;</code> and <code>InSet</code> constraint imposed by the use of <code>mkFieldError</code> makes sure it’s in the set of field names <code>names</code>.</p>
<p>Note the <code>myChecker</code> thing of the type <code>s -&gt; ExceptT e m a</code>. <code>s</code> is the type of thing that we parse from <code>Value</code> initially, then we can transform it and validate within the <code>EitherT</code> monad transformer, which may contain any monad <code>m</code>, such as a monad that allows you to lookup things in the database or anything else. Since I’d often like to transform the <code>s</code> value to other type, resulting value has a different type <code>a</code>. Finally as long as <code>e</code> is convert-able to JSON (note the <code>ToJSON e</code> constraint), we’re OK with accepting it as error message.</p>
<p>This approach allows you to grow a vocabulary of checkers-validators and since they are Kleisli arrows, they are easily composed with <code>(&gt;=&gt;)</code>. Note how we have a single way to do all validation, while <code>digestive-functors</code> has <code>validate</code>, <code>validateOptional</code>, and <code>validateM</code>. And when I had to use it, I also had to define <code>validateOptionalM</code>.</p>
<p>Sometimes we don’t want to validate anything, but <code>e</code> type variable will tend to be ambiguous, so it’s handy to define another version of <code>field</code> that does not require a checker at all:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The same as 'field', but does not require a checker.</span>

<span class="ot">field' ::</span> forall (<span class="ot">name ::</span> <span class="dt">Symbol</span>) (<span class="ot">names ::</span> [<span class="dt">Symbol</span>]) m a<span class="fu">.</span>
  ( <span class="dt">KnownSymbol</span> name
  , <span class="dt">InSet</span> name names
  , <span class="dt">Monad</span> m
  , <span class="dt">FromJSON</span> a )
  <span class="ot">=&gt;</span> <span class="dt">FormParser</span> names m a
field' <span class="fu">=</span> field <span class="fu">@</span>name check
  <span class="kw">where</span>
<span class="ot">    check ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> () m a
    check <span class="fu">=</span> return</code></pre></div>
<p>Such parsers can be combined using the applicative notation like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loginForm ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">FormParser</span> <span class="dt">LoginFields</span> m <span class="dt">LoginForm</span>
loginForm <span class="fu">=</span> <span class="dt">LoginForm</span>
  <span class="fu">&lt;$&gt;</span> field <span class="fu">@</span><span class="st">&quot;username&quot;</span> notEmpty
  <span class="fu">&lt;*&gt;</span> field <span class="fu">@</span><span class="st">&quot;password&quot;</span> notEmpty
  <span class="fu">&lt;*&gt;</span> field' <span class="fu">@</span><span class="st">&quot;remember_me&quot;</span></code></pre></div>
<h2 id="running-the-form">Running the form</h2>
<p>If we call the function that runs our form <code>runForm</code>, what its type should be? An obvious idea:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runForm ::</span> (<span class="dt">Monad</span> m, <span class="dt">ToJSON</span> b)
  <span class="ot">=&gt;</span> <span class="dt">FormParser</span> names m a <span class="co">-- ^ The form parser to run</span>
  <span class="ot">-&gt;</span> <span class="dt">Value</span>             <span class="co">-- ^ Input for the parser</span>
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b)        <span class="co">-- ^ Callback that is called on success</span>
  <span class="ot">-&gt;</span> m <span class="dt">Value</span>           <span class="co">-- ^ The result to send back to the client</span></code></pre></div>
<p>This is however is not good enough. <code>yesod-form</code> and <code>digestive-functors</code> show us a shortcoming to be aware of: validation is not only about checking individual fields, there may be a need to validate a field using values of other fields. So we need to provide a way to signal validation errors even when individual fields look OK.</p>
<p>A typical example would be the same login form. I’d like to signal a validation error if password is incorrect, but I can only check that if I already know the username. It’s not possible with <code>yesod-from</code> (you can only check that in handler and display a message but it won’t appear under the password field), but we can do better:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | This a type that user must return in the callback passed to the</span>
<span class="co">-- 'runForm' function. Quite simply, it allows you either report a error or</span>
<span class="co">-- finish successfully.</span>

<span class="kw">data</span> <span class="dt">FormResult</span> (<span class="ot">names ::</span> [<span class="dt">Symbol</span>]) a
  <span class="fu">=</span> <span class="dt">FormResultError</span> (<span class="dt">FieldError</span> names)
    <span class="co">-- ^ Form submission failed, here are the validation errors.</span>
  <span class="fu">|</span> <span class="dt">FormResultSuccess</span> a
    <span class="co">-- ^ Form submission succeeded, send this info.</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">runForm ::</span> (<span class="dt">Monad</span> m, <span class="dt">ToJSON</span> b)
  <span class="ot">=&gt;</span> <span class="dt">FormParser</span> names m a <span class="co">-- ^ The form parser to run</span>
  <span class="ot">-&gt;</span> <span class="dt">Value</span>             <span class="co">-- ^ Input for the parser</span>
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m (<span class="dt">FormResult</span> names b)) <span class="co">-- ^ Callback that is called on success</span>
  <span class="ot">-&gt;</span> m <span class="dt">Value</span>           <span class="co">-- ^ The result to send back to the client</span>
runForm (<span class="dt">FormParser</span> p) v f <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> p v
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">ParsingFailed</span> parseError <span class="ot">-&gt;</span> return <span class="fu">.</span> toJSON <span class="fu">$</span>
      def { responseParseError <span class="fu">=</span> pure parseError }
    <span class="dt">ValidationFailed</span> validationError <span class="ot">-&gt;</span> return <span class="fu">.</span> toJSON <span class="fu">$</span>
      def { responseFieldError <span class="fu">=</span> pure validationError }
    <span class="dt">Succeeded</span> x <span class="ot">-&gt;</span> <span class="kw">do</span>
      r' <span class="ot">&lt;-</span> f x
      return <span class="fu">.</span> toJSON <span class="fu">$</span> <span class="kw">case</span> r' <span class="kw">of</span>
        <span class="dt">FormResultError</span> validationError <span class="ot">-&gt;</span>
          def { responseFieldError <span class="fu">=</span> pure validationError }
        <span class="dt">FormResultSuccess</span> result <span class="ot">-&gt;</span>
          def { responseResult <span class="fu">=</span> toJSON result }</code></pre></div>
<p>To construct a <code>FieldError</code>, the user is still forced to use <code>pick</code> and then <code>(&lt;&gt;)</code> from <code>Data.Semigroup</code> to merge several <code>FieldError</code>s.</p>
<p>The rest is a simple boilerplate that renders the final <code>Value</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Response</span> (<span class="ot">names ::</span> [<span class="dt">Symbol</span>]) <span class="fu">=</span> <span class="dt">Response</span>
  {<span class="ot"> responseParseError ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
  ,<span class="ot"> responseFieldError ::</span> <span class="dt">Maybe</span> (<span class="dt">FieldError</span> names)
  ,<span class="ot"> responseResult     ::</span> <span class="dt">Value</span> }

<span class="kw">instance</span> <span class="dt">Default</span> (<span class="dt">Response</span> names) <span class="kw">where</span>
  def <span class="fu">=</span> <span class="dt">Response</span>
    { responseParseError <span class="fu">=</span> <span class="dt">Nothing</span>
    , responseFieldError <span class="fu">=</span> <span class="dt">Nothing</span>
    , responseResult     <span class="fu">=</span> <span class="dt">Null</span> }

<span class="kw">instance</span> <span class="dt">ToJSON</span> (<span class="dt">Response</span> names) <span class="kw">where</span>
  toJSON <span class="dt">Response</span> {<span class="fu">..</span>} <span class="fu">=</span> object
    [ <span class="st">&quot;parse_error&quot;</span>  <span class="fu">.=</span> responseParseError
    , <span class="st">&quot;field_errors&quot;</span> <span class="fu">.=</span> maybe (<span class="dt">Object</span> HM.empty) toJSON responseFieldError
    , <span class="st">&quot;result&quot;</span>       <span class="fu">.=</span> responseResult ]

<span class="kw">instance</span> <span class="dt">ToJSON</span> (<span class="dt">FieldError</span> names) <span class="kw">where</span>
  toJSON (<span class="dt">FieldError</span> m) <span class="fu">=</span> (object <span class="fu">.</span> fmap f <span class="fu">.</span> M.toAscList) m
    <span class="kw">where</span>
      f (name, err) <span class="fu">=</span> name <span class="fu">.=</span> err</code></pre></div>
<p>A complete example of <code>forma</code> usage would be something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds         #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE RecordWildCards   #-}</span>
<span class="ot">{-# LANGUAGE TypeApplications  #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Except</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">Web.Forma</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">type</span> <span class="dt">LoginFields</span> <span class="fu">=</span> <span class="ch">'[&quot;username&quot;, &quot;password&quot;, &quot;remember_me&quot;]</span>

<span class="kw">data</span> <span class="dt">LoginForm</span> <span class="fu">=</span> <span class="dt">LoginForm</span>
  {<span class="ot"> loginUsername   ::</span> <span class="dt">Text</span>
  ,<span class="ot"> loginPassword   ::</span> <span class="dt">Text</span>
  ,<span class="ot"> loginRememberMe ::</span> <span class="dt">Bool</span>
  }

<span class="ot">loginForm ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">FormParser</span> <span class="dt">LoginFields</span> m <span class="dt">LoginForm</span>
loginForm <span class="fu">=</span> <span class="dt">LoginForm</span>
  <span class="fu">&lt;$&gt;</span> field <span class="fu">@</span><span class="st">&quot;username&quot;</span> notEmpty
  <span class="fu">&lt;*&gt;</span> field <span class="fu">@</span><span class="st">&quot;password&quot;</span> notEmpty
  <span class="fu">&lt;*&gt;</span> field' <span class="fu">@</span><span class="st">&quot;remember_me&quot;</span>

<span class="ot">notEmpty ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">Text</span> m <span class="dt">Text</span>
notEmpty txt <span class="fu">=</span>
  <span class="kw">if</span> T.null txt
    <span class="kw">then</span> throwError <span class="st">&quot;This field cannot be empty.&quot;</span>
    <span class="kw">else</span> return txt

<span class="ot">myInput ::</span> <span class="dt">Value</span>
myInput <span class="fu">=</span> object
  [ <span class="st">&quot;username&quot;</span>    <span class="fu">.=</span> (<span class="st">&quot;Bob&quot;</span><span class="ot"> ::</span> <span class="dt">Text</span>)
  , <span class="st">&quot;password&quot;</span>    <span class="fu">.=</span> (<span class="st">&quot;123&quot;</span><span class="ot"> ::</span> <span class="dt">Text</span>)
  , <span class="st">&quot;remember_me&quot;</span> <span class="fu">.=</span> <span class="dt">True</span>
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> runForm loginForm myInput <span class="fu">$</span> \<span class="dt">LoginForm</span> {<span class="fu">..</span>} <span class="ot">-&gt;</span> <span class="kw">do</span>
    print loginUsername
    print loginPassword
    print loginRememberMe
    return (<span class="dt">FormResultSuccess</span> ())
  print r</code></pre></div>
<p>A good toy to play with to get a taste of <code>forma</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I’m yet to use <code>forma</code> in a large project. I’m playing with replacing <code>yesod-form</code> with <code>forma</code> in a personal project, and chances are guys at work will use it for a new greenfield project we have, so after a while I should have some feedback about this design.</p>

    </div>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="../js/put-anchors.js"></script>
    <footer>
      <a href="#top">top</a>
    </footer>

  </body>
</html>
